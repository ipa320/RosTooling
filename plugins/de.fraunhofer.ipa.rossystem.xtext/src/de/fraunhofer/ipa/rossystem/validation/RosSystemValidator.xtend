/*
 * generated by Xtext 2.30.0
 */
package de.fraunhofer.ipa.rossystem.validation

import org.eclipse.xtext.validation.Check
import system.Process
import system.System
import system.RosNode
import system.Component
import system.impl.RosNodeImpl
import system.Connection
import system.RosInterface
import system.impl.ConnectionImpl
import system.RosConnection
import system.RosSystemConnection
import system.impl.RosSystemConnectionImpl
import java.util.List
import system.RosPublisherReference
import system.RosServiceServerReference
import system.RosServiceClientReference
import system.RosActionServerReference
import system.RosSubscriberReference
import system.RosActionClientReference
import system.InterfaceReference
import system.SubSystem
import org.eclipse.emf.ecore.EObject
import java.util.ArrayList
import system.RosParameter
import ros.Parameter

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RosSystemValidator extends AbstractRosSystemValidator {

//  public static val INVALID_NAME = 'invalidName'
//
//  @Check
//  def checkGreetingStartsWithCapital(Greeting greeting) {
//      if (!Character.isUpperCase(greeting.name.charAt(0))) {
//          warning('Name should start with a capital',
//                  RosSystemPackage.Literals.GREETING__NAME,
//                  INVALID_NAME)
//      }
//  }

  public static val NOT_IN_THE_SYSTEM = "The element is not part of the system"
  public static val NOT_VALID_PATTERN = "The element has not a valid type"
  public static val TYPE_NOT_MATCH = "The ports have different types"
  public static val FROM_FILE_PATH = "FromFile"
  
  Object from_type
  Object to_type


  @Check
  def checkIfNodeInSystem(Process process) {
      for (Component node : process.components) {
          //var nodeImpl = node as RosNodeImpl
          var system = process.eContainer as System
          if (!system.components.contains(node)){
              error('The node '+node+' is not part of the system '+system.name
                  ,null,NOT_IN_THE_SYSTEM
              )
              info('Valid components for this process are '+system.components
                  ,null,NOT_IN_THE_SYSTEM)
          }
      }
  }
  
  @Check
  def fromFileHelper(System system ) {
      if (!system.fromFile.empty){
              info('The format for the FromFile attribute is: "NameOfThePackage/Path/to/ExecutableLaunchFile.launch.py"'
                  ,null,NOT_IN_THE_SYSTEM)
      }
      if (!system.fromFile.toString.contains("/")){
              error('Path not valid, the format for the FromFile attribute is: "NameOfThePackage/Path/to/ExecutableLaunchFile.launch.py"'
                  ,null,NOT_IN_THE_SYSTEM)
      }
  }

  @Check
  def checkIfInterfaceInSystem(Connection connection) {
      var connection_def = connection as RosSystemConnectionImpl
      var from_connection = connection_def.from
      var to_connection = connection_def.to
      var system = connection.eContainer as System
      var List<RosInterface> AllInterfaces = newArrayList

      for (Component component : system.components){
          if(component.class.toString.contains("RosNode")){
              var rosnode = component as RosNode
              for(RosInterface interface : rosnode.rosinterfaces){
                AllInterfaces.add(interface)
              }
          }
          if (component.class.toString.contains("SubSystem")) {
              var subsystem = component as SubSystem
              for(subcomponent: (subsystem.system as System).components){
                 var rosnode = subcomponent as RosNode
                  for(RosInterface interface : rosnode.rosinterfaces){
                    AllInterfaces.add(interface)
                  }
              }
          }
      }

      if (!AllInterfaces.contains(from_connection)){
              info('Valid interfaces for this process are '+AllInterfaces
                  ,null,NOT_IN_THE_SYSTEM)
              error('The interface '+from_connection+' is not part of the system '+system.name
                  ,null,NOT_IN_THE_SYSTEM)
      } else {
          if (!AllInterfaces.toArray.contains(to_connection)){
                  info('Valid interfaces for this process are '+AllInterfaces
                      ,null,NOT_IN_THE_SYSTEM)
                  error('The interface '+to_connection+' is not part of the system '+system.name
                      ,null,NOT_IN_THE_SYSTEM)
      }
    }
  }

  @Check
  def checkPortPatterns(Connection connection) {
      var List<String> validFromType = newArrayList('RosPublisherReference','RosServiceServerReference','RosActionServerReference')
      var List<String> validToType = newArrayList('RosSubscriberReference','RosServiceClientReference','RosActionClientReference')
      var connection_def = connection as RosSystemConnectionImpl
      var from_connection = connection_def.from
      var to_connection = connection_def.to
      if(!validFromType.contains(from_connection.reference.eClass.name)){
              error('The type of the interface '+from_connection+' is not valid, the output port can have only one of the following types '+validFromType
                  ,null,NOT_VALID_PATTERN)
      } else {
          if (from_connection.reference.eClass.name=='RosPublisherReference'){
              if(!(to_connection.reference.eClass.name=='RosSubscriberReference')){
                error('The input port (to) must be a Subscriber'
                  ,null,NOT_VALID_PATTERN)
          }}
          if (from_connection.reference.eClass.name=='RosServiceServerReference'){
              if(!(to_connection.reference.eClass.name=='RosServiceClientReference')){
                  error('The input port (to) must be a Service Client'
                      ,null,NOT_VALID_PATTERN)
          }}
          if (from_connection.reference.eClass.name=='RosActionServerReference'){
              if(!(to_connection.reference.eClass.name=='RosActionClientReference')){
                  error('The input port (to) must be an Action Client'
                      ,null,NOT_VALID_PATTERN)
          }}
      }
  }

  @Check
  def MatchPortMsgs(Connection connection){
      var connection_def = connection as RosSystemConnectionImpl
      var from_connection = connection_def.from
      var to_connection = connection_def.to
      if (from_connection.reference.eClass.name=='RosPublisherReference'){
          var from_top = from_connection.reference as RosPublisherReference
          from_type = from_top.from.message
      }
      if (from_connection.reference.eClass.name=='RosServiceServerReference'){
          var from_ser = from_connection.reference as RosServiceServerReference
          from_type = from_ser.from.service
      }
      if (from_connection.reference.eClass.name=='RosActionServerReference'){
          var from_act = from_connection.reference as RosActionServerReference
          from_type = from_act.from.action
      }
      if (to_connection.reference.eClass.name=='RosSubscriberReference'){
          var to_top = to_connection.reference as RosSubscriberReference
          to_type = to_top.from.message
      }
      if (to_connection.reference.eClass.name=='RosServiceClientReference'){
          var to_top = to_connection.reference as RosServiceClientReference
          to_type = to_top.from.service
      }
      if (to_connection.reference.eClass.name=='RosActionClientReference'){
          var to_top = to_connection.reference as RosActionClientReference
          to_type = to_top.from.action
      }

      if (from_type !== to_type){
          error("A connection can only be formed by interfaces with the same type, "+from_connection.name+" and "+to_connection.name+" have different types.", null, TYPE_NOT_MATCH)
      }
  }
  
/*Check parameter assignments */
    String expected_type = null;
    String value_type = null;
    List<EObject> expected_sub_types;
    ArrayList<String> expected_sub_names;
    List<EObject> value_sub_type;
    public static val INVALID_TYPE = 'invalidType'
    public static val INVALID_NAME = 'invalidName'
    public static val INVALID_LENGHT = "invalidLeght"
    
    int i;
    int j;
    String name_given_element;
    String sub_element_type;
    boolean sub_element;
    EObject expected_sub_type = null;
    
    @Check
    def void CheckParameter (RosParameter rosparam){
        CheckParameterValue(rosparam.from, rosparam.value);
    }
    
    def void CheckParameterValue (EObject expected_parameter, EObject given_parameter){

        if (expected_parameter.eClass.name=="Parameter"){
            expected_type = (expected_parameter as Parameter).type.eClass.name;
            expected_sub_types = expected_parameter.eContents.get(0).eContents.toList
            sub_element = false;
            
        } else {            
            expected_type = expected_parameter.eClass.name;
            expected_sub_types = expected_parameter.eContents.toList
            sub_element = true;
        }
        value_type = given_parameter.eClass.name;

        // LIST
        if (expected_type.contains("ParameterListType") || expected_type.contains("ParameterSequence")){
            //expected_sub_types = expected_parameter.eContents.get(0).eContents.toList
            if (given_parameter.class.toString.contains("ParameterSequence")){
                value_sub_type = given_parameter.eContents.toList
                if (value_sub_type.length==expected_sub_types.length){
                    for (i=0;i<value_sub_type.length;i++){
                        if (expected_sub_types.get(i).eClass.name.matches("ParameterStructType|ParameterListType|ParameterSequence")){
                            try{
                                CheckParameterValue((expected_sub_types.get(i).eContents.get(0)),(value_sub_type.get(i).eContents.get(0).eContents.get(0)));
                            } catch (IndexOutOfBoundsException error) {
                                // Output expected IndexOutOfBoundsExceptions.                              
                            }
                        }
                        if(!check_matched_type(expected_sub_types.get(i).eClass.name,value_sub_type.get(i).eClass.name)){
                            error( "Element "+i+" , expected type: "+expected_sub_types.get(i).eClass.name+" given type "+value_sub_type.get(i).eClass.name, null, INVALID_TYPE)
                        }
                    }
                } else {
                    error( "Expect a list of "+expected_sub_types.length+" elements", null, INVALID_LENGHT)
                }
            } else {
                error( "Expect a list of elements; format { , ,...}", null, INVALID_LENGHT)
                }
            
        }
        // ARRAY
        else if (expected_type.contains("ParameterArrayType")){
            //expected_sub_types = expected_parameter.eContents.get(0).eContents.toList
            if (given_parameter.class.toString.contains("ParameterSequence")){
                value_sub_type = given_parameter.eContents.toList
                expected_type=expected_sub_types.get(0).eClass.name
                for (i=0;i<value_sub_type.length;i++){
                    if(!check_matched_type(expected_type,value_sub_type.get(i).eClass.name)){
                        error( "Element "+i+" , expected type: "+expected_type+" given type "+value_sub_type.get(i).eClass.name, null, INVALID_TYPE)
                    }
                }
                } 
            else {
                error( "Expect a list of elements; format { , , }", null, INVALID_LENGHT)
                }
        }
        // STRUCT
        else if (expected_type.contains("ParameterStruct")){
            value_sub_type = given_parameter.eContents.toList;
            expected_sub_names = new ArrayList<String>();

            for (i=0; i<expected_sub_types.length;i++){ 
                expected_sub_names.add(i,getName(expected_sub_types.get(i).toString));
            }

            for (i=0; i<value_sub_type.length;i++){ 
                if (sub_element){
                    name_given_element = getName(value_sub_type.get(i).toString) 
                }else {
                    name_given_element = getName(value_sub_type.get(i).toString)
                }
                 sub_element_type = value_sub_type.get(i).eContents.get(0).eClass.name
                
                if (!(expected_sub_names.contains(name_given_element))){
                    error("Element expected names: "+expected_sub_names+ "  instead of: "+name_given_element,null, INVALID_NAME)
                    info("Struct format: value { {first_element {value value_fisrt element}}, {second_element {value value_second element}}}",null, INVALID_NAME)
                } else {

                    for (j=0;j<expected_sub_types.length;j++){
                        if (expected_sub_types.get(j).toString.contains("name")){   
                        if ( ((getName(expected_sub_types.get(j).toString))==name_given_element) ){
                            if (expected_sub_types.get(j).eContents.get(0).eClass.name.matches("ParameterStructType|ParameterListType|ParameterSequence")){ 
                                CheckParameterValue((expected_sub_types.get(j).eContents.get(0)),(value_sub_type.get(i).eContents.get(0)));
                                //CheckParameterValue((expected_sub_types.get(j).eContents.get(0)),(value_sub_type.get(i).eContents.get(0).eContents.get(0)));
                            }
                            try{
                                expected_sub_type = expected_sub_types.get(j);
                                if (expected_sub_type.eContents.size > 0){
                                if (!check_matched_type(expected_sub_types.get(j).eContents.get(0).eClass.name,sub_element_type)){
                                    error( "Element "+getName(expected_sub_types.get(j).toString)+" , expected type: "+expected_sub_types.get(j).eContents.get(0).eClass.name+
                                    " given type "+sub_element_type, null, INVALID_TYPE)
                                    info("Struct format: value { {FIRST {value VALUE_FIRST}}, {SECOND {value VALUE_SECOND}}}",null, INVALID_NAME)}
                                    }
                            } catch (IndexOutOfBoundsException error) {
                                // Output expected IndexOutOfBoundsExceptions.                              
                            }
        }}}}}}
        
        // INT, BOOL, DOUBLE, BASE64, STRING
        else {
           if(!check_matched_type(expected_type,value_type)){
                error("Mismatched input "+value_type+ " expecting "+ expected_type, null, INVALID_TYPE)
            }
        }
    }


    def boolean check_matched_type(String expected_type,String given_type){
        if (given_type.contains("ParameterSequence") && expected_type.contains("ParameterList")){
            return true;
        }
        else if (expected_type.contains(given_type)){
            return true;
        } else {
            return false;
        }
    }
    
    def String getName(String Element){
        if (Element.length()>0){
            return Element.substring(Element.indexOf("name:")+5,Element.indexOf(")"))
        }
    }
    
    def String getValue(String Element){
        return Element.substring(Element.indexOf("value:")+6,Element.indexOf(")"))
    }

    /*Parameters Helper*/
    public static val PARAMETER_HELP = 'paramInfo'
            
    @Check
    def void BinaryHelp (Parameter param){
        if(param.type.toString.contains("Base64") && !(param.toString.contains('0b') ||param.toString.contains('0B'))){
            info("HELP: A binary value must start with '0b'", null, PARAMETER_HELP)
        }
    }
    
    @Check
    def void ArrayHelp (Parameter param){
        if(param.type.toString.contains("Array")){
            info("HELP: Array parameter format:\n { type TYPE {default VALUE, VALUE }\n example:\n type Boolean default true, true} ", null, PARAMETER_HELP)
        }
    }
    
    @Check
    def void ListHelp (Parameter param){
        if(param.type.toString.contains("List")){
            info("HELP: List parameter format:\n { TYPE default VALUE,TYPE default VALUE }\n example:\n Integer default 5, Boolean default true ", null, PARAMETER_HELP)
        }
    }
    
    @Check
    def void StructHelp (Parameter param){
        if(param.type.toString.contains("Struc")){
            info("HELP: Struct parameter format:\n { NAME TYPE default VALUE, NAME TYPE default VALUE }\n example:\n my_int Integer default 5, my_bool Boolean default true ", null, PARAMETER_HELP)
        }
    }
  

}
